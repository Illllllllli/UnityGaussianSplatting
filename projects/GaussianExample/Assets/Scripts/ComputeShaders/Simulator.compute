#pragma once
// 用于物理模拟计算
#pragma kernel select_vertices
#pragma kernel clean_selected_vertices
#pragma kernel initialize_covariance
#pragma kernel get_local_embeded_tets
#pragma kernel get_global_embeded_tet
#pragma kernel init_fem_bases
#pragma kernel init_inv_mass
#pragma kernel init_rigid
#pragma kernel compute_triangle_aabbs
#pragma kernel compute_morton_and_indices
#pragma kernel get_sorted_triangle_aabbs
#pragma kernel reset_aabb
#pragma kernel construct_internal_nodes
#pragma kernel compute_internal_aabbs
#pragma kernel query_collision_pairs
#pragma kernel query_collision_triangles

//根据不同面数情况选择不同线程数量的方法
#pragma kernel aabb_reduce_512
#pragma kernel aabb_reduce_256
#pragma kernel aabb_reduce_128
#pragma kernel aabb_reduce_64
#pragma kernel aabb_reduce_32
#pragma kernel aabb_reduce_16
#pragma kernel aabb_reduce_8
#pragma kernel aabb_reduce_4
#pragma kernel aabb_reduce_2
#pragma kernel aabb_reduce_1

/// 物理求解方法
#pragma kernel apply_external_force
#pragma kernel solve_fem_constraints
#pragma kernel solve_triangle_point_distance_constraint
#pragma kernel pbd_post_solve
#pragma kernel pbd_advance
#pragma kernel solve_rigid_init_mass_center
#pragma kernel solve_rigid_compute_A
#pragma kernel solve_rigid_compute_R
#pragma kernel solve_rigid_update_x
#pragma kernel apply_interpolation_i
#pragma kernel apply_interpolation_ii

#include "MathUtils.hlsl"
#include "SimulateUtils.hlsl"
#include "LBVH.hlsl"

//预定义量
#define BLOCK_SIZE 256
#define CULLING_BLOCK_SIZE 128
#define PI 3.1415926

// 输入数据
// 全局物理参数
float gravity; //重力
float dt; // 模拟的子步长
float damping_coefficient; // 阻尼系数
int z_up; // z轴坐标系方向
float ground_height; //地面高度
float collision_stiffness; // 碰撞刚度系数

// 控制器参数
float3 controller_position; //控制器的位置
float3 controller_velocity; //控制器的速度
float3 controller_angle_velocity; //控制器的角速度
float controller_radius; //控制器影响半径

// 全局GS参数
int gs_total_count; // GS数量
int gs_object_count; // GS物体数量
// GS缓冲区参数
RWStructuredBuffer<uint3> gs_position_buffer; //gs位置数据
RWStructuredBuffer<uint> gs_other_buffer; //gs缩放和旋转数据

// 局部(单物体)GS参数
int gs_local_count;
int gs_local_offset;


// 全局网格参数
int vertices_total_count;
int face_total_count;
int cell_total_count;
int boundary;
// 网格缓冲区参数
RWStructuredBuffer<float3> vertices_x_buffer; //动态顶点数据
RWStructuredBuffer<float3> vertices_X_buffer; //原始顶点数据
RWStructuredBuffer<int> vert_group_buffer; // 顶点组数据

RWStructuredBuffer<int> edge_indices_buffer; // 边索引
RWStructuredBuffer<int> face_indices_buffer; // 面索引
RWStructuredBuffer<int> cell_indices_buffer; // 四面体索引

//注意：为了实现原子加法，类型由float更改为uint
RWStructuredBuffer<float> vert_velocity_buffer; //顶点速度缓冲区
RWStructuredBuffer<float> vert_force_buffer; //顶点受力缓冲区
RWStructuredBuffer<uint> vert_mass_buffer; //顶点质量
RWStructuredBuffer<float> vert_inv_mass_buffer; //顶点逆质量
RWStructuredBuffer<float3> vert_new_x_buffer; //顶点新位置缓冲区
//注意：为了实现原子加法，类型由float3更改为uint3
RWStructuredBuffer<uint3> vert_delta_pos_buffer; //顶点位移增量缓冲区
RWStructuredBuffer<int> vert_selected_indices_buffer; //被选中的顶点的索引列表（1为被选中）
RWStructuredBuffer<int> rigid_vert_group_buffer; //刚体组索引
RWStructuredBuffer<float> cell_ds_inv_buffer; // 逆变形梯度矩阵
RWStructuredBuffer<float> cell_volume_init_buffer; //四面体初始体积
RWStructuredBuffer<float> cell_density_buffer; // 四面体密度
RWStructuredBuffer<float> cell_mu_lambda_multiplier_buffer; //四面体剪切模量缓冲区

//注意：因为double的原子加法难以自行实现，所以更改原始数据类型为float
//注意：为了实现原子加法，类型由float更改为uint
RWStructuredBuffer<uint> rigid_mass_buffer; //刚体质量
RWStructuredBuffer<uint> rigid_mass_center_init_buffer; //刚体初始质心
RWStructuredBuffer<uint> rigid_mass_center_buffer; //刚体质心
RWStructuredBuffer<uint> rigid_angle_velocity_matrix_buffer; // 刚体角速度矩阵
RWStructuredBuffer<float> rigid_rotation_matrix_buffer; // 刚体旋转矩阵

RWStructuredBuffer<lbvh_aabb> triangle_aabbs_buffer; //排序前的三角面的轴对齐包围盒缓冲区
RWStructuredBuffer<lbvh_aabb> sorted_triangle_aabbs_buffer; //排序后的三角面轴对齐包围盒缓冲区
RWStructuredBuffer<lbvh_aabb> partial_aabb_buffer; //部分轴对齐包围盒缓冲区
RWStructuredBuffer<uint2> morton_code_buffer; //排序前的莫顿编码缓冲区
RWStructuredBuffer<uint2> sorted_morton_code_buffer; //排序后的莫顿编码缓冲区
RWStructuredBuffer<int> indices_buffer; //排序前的面片索引缓冲区
RWStructuredBuffer<int> sorted_indices_buffer; //排序后的面片索引缓冲区
RWStructuredBuffer<int> face_flags_buffer; //标记每个面片的状态的缓冲区
RWStructuredBuffer<lbvh_aabb> lbvh_aabbs_buffer; //LBVH树每个树节点的包围盒缓冲区
RWStructuredBuffer<lbvh_node> lbvh_nodes_buffer; //LBVH树节点的父子关系缓冲区
RWStructuredBuffer<uint> lbvh_sort_buffer; //LBVH的中间排序结果缓冲区

RWStructuredBuffer<int2> collision_pairs_buffer; //粗略碰撞对缓冲区
RWStructuredBuffer<int4> exact_collision_pairs_buffer; //精确碰撞对缓冲区
RWStructuredBuffer<int> total_pairs_buffer; //粗略碰撞对数量计数器缓冲区
RWStructuredBuffer<int> total_exact_pairs_buffer; //精确碰撞对数量计数器缓冲区

RWStructuredBuffer<float> cov_buffer; //协方差矩阵
RWStructuredBuffer<float> local_tet_x_buffer; //本地四面体顶点坐标缓冲区
RWStructuredBuffer<float> local_tet_w_buffer; //本地四面体顶点坐标权重缓冲区
RWStructuredBuffer<int> global_tet_idx_buffer; //全局四面体顶点坐标索引缓冲区
RWStructuredBuffer<float> global_tet_w_buffer; //全局四面体顶点坐标权重缓冲区

// 局部(单物体)网格参数
int cell_local_count;
int cell_local_offset;

/// 控制器更新部分 ///

/**
 * 根据控制器位置更新选定的顶点
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void select_vertices(uint3 id : SV_DispatchThreadID)
{
    const uint idx = id.x;
    const float3 pos = vertices_x_buffer[idx];
    const float dist = distance(pos, controller_position);

    if (dist <= controller_radius)
    {
        vert_selected_indices_buffer[idx] |= 1; // 使用最低位表示选中状态
    }
}

/**
 * 清除选定的顶点
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void clean_selected_vertices(uint3 id : SV_DispatchThreadID)
{
    const uint idx = id.x;
    vert_selected_indices_buffer[idx] &= ~1; // 清除最低位
}

/// 初始化部分 ///

/**
 * 初始化协方差矩阵
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void initialize_covariance(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < gs_total_count)
    {
        const float3 scale = load_gs_scale(gs_other_buffer, idx);
        const float4 rotation = load_gs_rotation(gs_other_buffer, idx);
        const float3x3 s = build_scaling_matrix(scale);
        const float3x3 r = build_rotation_matrix(rotation);
        const float3x3 l = mul(r, s);
        const float3x3 lt = transpose(l);
        const float3x3 cov = mul(l, lt);
        store_matrix_float(cov, cov_buffer, idx);
    }
}

/**
 * 获取GS全局嵌入四面体
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void get_local_embeded_tets(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < gs_total_count)
    {
        const float fac = 1.5f;
        const float3 center = load_gs_pos(gs_position_buffer, idx);

        // 协方差矩阵的特征分解
        float eval[3];
        float evec[3][3];

        float A[3][3];
        copy_matrix_to_array3x3(load_matrix_float(cov_buffer, idx), A);
        get_sym_eigen3x3(A, eval, evec);
        const float3 sqrt_eval = sqrt(copy_array_to_vector3(eval));

        // 确定最大（mxV）、最小（mnV）和中间（mdV）特征值的索引
        const int max_v = eval[0] > max(eval[1], eval[2]) ? 0 : (eval[1] > max(eval[0], eval[2]) ? 1 : 2);
        const int min_v = eval[0] < min(eval[1], eval[2]) ? 0 : (eval[1] < min(eval[0], eval[2]) ? 1 : 2);
        const int mid_v = 3 ^ (max_v ^ min_v);

        float x0[3];
        // 顶点0：沿最大特征方向拉伸
        // 顶点1-3：在中间特征方向平面内按120°分布
        for (int i = 0; i < 3; i++)
        {
            local_tet_x_buffer[(idx * 4 + 0) * 3 + i] = center[i] + sqrt_eval[max_v] * evec[i][max_v] * fac;
            x0[i] = center[i] - sqrt_eval[max_v] * evec[i][max_v];
        }
        const float3 n = normalize(float3(evec[0][max_v], evec[1][max_v], evec[2][max_v])); // 主方向单位向量
        const float3 n_t = normalize(float3(evec[0][mid_v], evec[1][mid_v], evec[2][mid_v])); // 中间方向单位向量
        // 计算正交向量u和v
        const float3 u = cross(n, n_t);
        const float3 v = cross(n, u);
        const float r = sqrt_eval[mid_v];

        for (int i = 0; i < 3; i++)
        {
            // 生成三个环绕点（角度0°, 120°, -120°）
            //每行对应一个顶点
            local_tet_x_buffer[(idx * 4 + 1) * 3 + i] = x0[i] + r * (cos(0) * u[i] + sin(0) * v[i]) * fac;
            local_tet_x_buffer[(idx * 4 + 2) * 3 + i] = x0[i] + r * (cos(+2.f / 3.f * PI) * u[i] + sin(+2.f / 3.f * PI)
                * v[i]) * fac;
            local_tet_x_buffer[(idx * 4 + 3) * 3 + i] = x0[i] + r * (cos(-2.f / 3.f * PI) * u[i] + sin(-2.f / 3.f * PI)
                * v[i]) * fac;
        }
        // 计算插值权重
        // 构造Ds_local矩阵（顶点0-3相对于顶点3的坐标差）
        float ds_local[3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                ds_local[i][j] = local_tet_x_buffer[(idx * 4 + j) * 3 + i] - local_tet_x_buffer[(idx * 4 + 3) * 3 + i];
            }
        }
        // 求逆矩阵
        const float3x3 ds_local_inv = inverse_3x3(ds_local);
        // 计算中心点与顶点3的坐标差
        float3 d_xyz = center;
        d_xyz.x -= local_tet_x_buffer[(idx * 4 + 3) * 3 + 0];
        d_xyz.y -= local_tet_x_buffer[(idx * 4 + 3) * 3 + 1];
        d_xyz.z -= local_tet_x_buffer[(idx * 4 + 3) * 3 + 2];
        // 通过逆矩阵变换得到权重并保存到全局数据中
        const float3 w = mul(ds_local_inv, d_xyz);
        for (int i = 0; i < 3; i++)
        {
            local_tet_w_buffer[idx * 3 + i] = w[i];
        }
    }
}


/**
 * 获取GS全局嵌入四面体
 * 由于原函数对每一个四面体都调用一次，感觉性能浪费严重，尝试改成对一个物体调用一次，一个线程负责单个GS对单个四面体的权重计算
 * 看起来一个GS对应
 * @param id 线程ID
 */
// 使用groupshared 数组优化计算速度
[numthreads(BLOCK_SIZE,1,1)]
void get_global_embeded_tet(uint3 id : SV_DispatchThreadID)
{
    const uint idx = id.x;
    const int gs_local_id = idx / 4;
    const int c = idx % 4;
    if (gs_local_id < gs_local_count)
    {
        const int gs_global_id = gs_local_id + gs_local_offset;
        const float3 local_pos = float3(local_tet_x_buffer[(gs_global_id * 4 + c) * 3 + 0],
                                        local_tet_x_buffer[(gs_global_id * 4 + c) * 3 + 1],
                                        local_tet_x_buffer[(gs_global_id * 4 + c) * 3 + 2]);
        // 改：一个线程遍历所有的四面体
        for (int global_embeded_tid = cell_local_offset; global_embeded_tid < cell_local_count + cell_local_offset;
             global_embeded_tid++)
        {
            // 简易包围盒剔除四面体
            const float3 global_pos[4] = {
                vertices_X_buffer[cell_indices_buffer[global_embeded_tid * 4 + 0]],
                vertices_X_buffer[cell_indices_buffer[global_embeded_tid * 4 + 1]],
                vertices_X_buffer[cell_indices_buffer[global_embeded_tid * 4 + 2]],
                vertices_X_buffer[cell_indices_buffer[global_embeded_tid * 4 + 3]]
            };
            const float3 min_pos = min(min(global_pos[0], global_pos[1]), min(global_pos[2], global_pos[3]));
            if (any(local_pos < min_pos))
            {
                continue;
            }
            const float3 max_pos = max(max(global_pos[0], global_pos[1]), max(global_pos[2], global_pos[3]));
            if (any(local_pos > max_pos))
            {
                continue;
            }
            // ds是全局四面体的三个顶点和全局四面体主顶点的坐标向量差
            const float3x3 ds = transpose(float3x3(global_pos[0] - global_pos[3],
                                                   global_pos[1] - global_pos[3],
                                                   global_pos[2] - global_pos[3]));


            const float3x3 ds_inv = inverse_3x3(ds);
            const float3 pos = vertices_X_buffer[cell_indices_buffer[global_embeded_tid * 4 + 3]];
            // local_tet_x是我们计算生成的四面体坐标
            // dxyz是本地四面体的四个顶点之一和全局四面体的主顶点的坐标向量差
            const float3 dxyz = local_pos - pos;
            const float3 w = mul(ds_inv, dxyz);
            // “两层嵌入”核心步骤：每一个GS先嵌入local_embeded_tet，然后在这里用local_embeded_tet的数据嵌入到global_embeded_tet中
            // 如果没有满足条件的就置为0
            if (w[0] >= 0.f && w[1] >= 0.f && w[2] >= 0.f &&
                w[0] + w[1] + w[2] <= 1.f)
            {
                global_tet_idx_buffer[gs_global_id * 4 + c] = global_embeded_tid;
                global_tet_w_buffer[(gs_global_id * 4 + c) * 3 + 0] = w[0];
                global_tet_w_buffer[(gs_global_id * 4 + c) * 3 + 1] = w[1];
                global_tet_w_buffer[(gs_global_id * 4 + c) * 3 + 2] = w[2];
                break;
            }
        }
    }
}

/**
 * 初始化FEM模拟
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void init_fem_bases(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;

    if (idx < cell_total_count)
    {
        // 计算顶点距离差
        const float3x3 DS = transpose(float3x3(
            vertices_X_buffer[cell_indices_buffer[idx * 4 + 0]] - vertices_X_buffer[
                cell_indices_buffer[idx * 4 + 3]],
            vertices_X_buffer[cell_indices_buffer[idx * 4 + 1]] - vertices_X_buffer[
                cell_indices_buffer[idx * 4 + 3]],
            vertices_X_buffer[cell_indices_buffer[idx * 4 + 2]] - vertices_X_buffer[
                cell_indices_buffer[idx * 4 + 3]]
        ));

        const float3x3 DS_inv = inverse_3x3(DS);
        store_matrix_float(DS_inv, cell_ds_inv_buffer, idx);
        // 计算体积
        const float volume = abs(determinant(DS / 6.0f));
        cell_volume_init_buffer[idx] = volume;
        // 更新每个顶点的质量
        for (int i = 0; i < 4; i++)
        {
            atomic_add_float(vert_mass_buffer, cell_indices_buffer[idx * 4 + i],
                             0.25f * cell_density_buffer[idx] * volume);
        }
    }
}

/**
 * 初始化逆质量.
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void init_inv_mass(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    const float mass = asfloat(vert_mass_buffer[idx]);
    if (idx < vertices_total_count)
    {
        if (boundary == 0 && mass == 0.f)
        {
            vert_inv_mass_buffer[idx] = 0.f;
        }

        else if (boundary == 1 && (mass == 0.f || vertices_X_buffer[idx][2] >= 1.3f))
        {
            // Fox
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 2 && (mass == 0.f || vertices_X_buffer[idx][1] >= (0.79f -
            1.5f)))
        {
            // Bear
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 3 && (mass == 0.f || vertices_X_buffer[idx][1] >= 0.3f))
        {
            // JLS
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 4 && (mass == 0.f || vertices_X_buffer[idx][1] >= -0.1f))
        {
            // revised basket
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 10 && (mass == 0.f || vertices_X_buffer[idx][2] <= -0.5f))
        {
            // ficus
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 20 && (mass == 0.f || vertices_X_buffer[idx][0] <= 0.3f))
        {
            // microphone
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else if (boundary == 30 && (mass == 0.f || vertices_X_buffer[idx][2] >= 0.8026f))
        {
            // chair
            vert_inv_mass_buffer[idx] = 0.f;
        }
        else
        {
            vert_inv_mass_buffer[idx] = 1.f / mass;
        }
    }
}

/**
 * 初始化刚体模拟
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void init_rigid(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count && rigid_vert_group_buffer[idx] >= 0)
    {
        const int rigid_object_id = rigid_vert_group_buffer[idx];
        for (int i = 0; i < 3; i++)
        {
            //计算质心
            atomic_add_float(rigid_mass_center_init_buffer, rigid_object_id * 3 + i,
                             asfloat(vert_mass_buffer[idx]) * vertices_X_buffer[idx][i]);
        }
        atomic_add_float(rigid_mass_buffer, rigid_object_id, asfloat(vert_mass_buffer[idx]));
    }
}


/// 碰撞检测部分 ///
//compute_triangle_aabbs,query_collision_triangles和solve_triangle_point_distance_constraint共用
float collision_detection_dist;
int aabb_grid_size; // 线程块总数
/**
 * 计算三角面AABB包围盒
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void compute_triangle_aabbs(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < face_total_count)
    {
        const float3 verts[3] = {
            vertices_x_buffer[face_indices_buffer[idx * 3]],
            vertices_x_buffer[face_indices_buffer[idx * 3 + 1]],
            vertices_x_buffer[face_indices_buffer[idx * 3 + 2]]
        };
        triangle_aabbs_buffer[idx].lower = min(min(verts[0], verts[1]), verts[2]) - collision_detection_dist;
        triangle_aabbs_buffer[idx].upper = max(max(verts[0], verts[1]), verts[2]) + collision_detection_dist;
    }
}

/**
 * 计算Morton码并生成索引
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void compute_morton_and_indices(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < face_total_count)
    {
        const lbvh_aabb whole = partial_aabb_buffer[0];
        float3 p = get_aabb_center(triangle_aabbs_buffer[idx]);
        p -= whole.lower;
        p /= (whole.upper - whole.lower);
        //x存储低位，y存储高位
        morton_code_buffer[idx].x = idx;
        morton_code_buffer[idx].y = (get_morton_code(p));
        indices_buffer[idx] = idx;
    }
}

/**
 * 获取排序后的三角面包围盒
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void get_sorted_triangle_aabbs(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < face_total_count)
    {
        sorted_triangle_aabbs_buffer[idx] = triangle_aabbs_buffer[sorted_indices_buffer[idx]];
    }
}

/**
 * 初始化BVH的AABB节点
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void reset_aabb(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    const int internal_nodes_count = face_total_count - 1;
    const int nodes_count = face_total_count * 2 - 1;
    if (idx < nodes_count)
    {
        if (idx < internal_nodes_count)
        {
            lbvh_aabbs_buffer[idx].lower = asfloat(0x7f7fffff);
            lbvh_aabbs_buffer[idx].upper = asfloat(0xff7fffff);
        }
        else
        {
            lbvh_aabbs_buffer[idx] = sorted_triangle_aabbs_buffer[idx - internal_nodes_count];
        }
    }
}

/**
 * 构建LBVH内部节点
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void construct_internal_nodes(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    int internal_nodes_count = face_total_count - 1;
    if (idx < internal_nodes_count)
    {
        const uint2 ij = determine_range(sorted_morton_code_buffer, face_total_count, idx);
        const uint gamma = find_split(sorted_morton_code_buffer, face_total_count, ij.x, ij.y);
        lbvh_nodes_buffer[idx].left_idx = gamma;
        lbvh_nodes_buffer[idx].right_idx = gamma + 1;
        if (min(ij.x, ij.y) == gamma)
        {
            lbvh_nodes_buffer[idx].left_idx += face_total_count - 1;
        }
        if (max(ij.x, ij.y) == gamma + 1)
        {
            lbvh_nodes_buffer[idx].right_idx += face_total_count - 1;
        }
        lbvh_nodes_buffer[lbvh_nodes_buffer[idx].left_idx].parent_idx = idx;
        lbvh_nodes_buffer[lbvh_nodes_buffer[idx].right_idx].parent_idx = idx;
    }
}

/**
 * 计算LBVH内部的AABB节点
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void compute_internal_aabbs(uint3 id : SV_DispatchThreadID)
{
    int idx = id.x;
    const int internal_node_count = face_total_count - 1;
    if (idx < face_total_count)
    {
        idx += internal_node_count;
        uint parent = lbvh_nodes_buffer[idx].parent_idx;
        while (parent != 0xffffffff)
        {
            int old;
            InterlockedCompareExchange(face_flags_buffer[parent], 0, 1, old);
            if (old == 0)
            {
                return;
            }
            const uint l_idx = lbvh_nodes_buffer[parent].left_idx;
            const uint r_idx = lbvh_nodes_buffer[parent].right_idx;
            const lbvh_aabb l_box = lbvh_aabbs_buffer[l_idx];
            const lbvh_aabb r_box = lbvh_aabbs_buffer[r_idx];
            lbvh_aabbs_buffer[parent] = merge_aabb(l_box, r_box);

            // 更新父节点
            parent = lbvh_nodes_buffer[parent].parent_idx;
        }
    }
}


/**
 * 查询碰撞对
 * @param id 线程ID
 */
groupshared uint shared_query_collision_in[128];
groupshared uint shared_query_collision_global_offset[1];

[numthreads(BLOCK_SIZE,1,1)]
void query_collision_pairs(uint3 id : SV_DispatchThreadID, uint3 g_tid : SV_GroupThreadID)
{
    const int max_collision_per_node = 64;
    const int block_size = 64;
    const uint internal_nodes_count = uint(face_total_count - 1);
    // const int pad = 1;
    uint num_found = 0;
    uint thread_pairs[max_collision_per_node];
    int idx = id.x;
    if (idx < face_total_count)
    {
        uint stack[64];
        uint stack_idx = 0;
        stack[stack_idx++] = 0xffffffff;
        uint node = 0;
        do
        {
            const uint l_idx = lbvh_nodes_buffer[node].left_idx;
            const uint r_idx = lbvh_nodes_buffer[node].right_idx;

            const bool overlap_l = intersects_aabb(triangle_aabbs_buffer[idx], lbvh_aabbs_buffer[l_idx]);
            const bool overlap_r = intersects_aabb(triangle_aabbs_buffer[idx], lbvh_aabbs_buffer[r_idx]);
            const bool is_leaf_l = l_idx >= internal_nodes_count;
            const bool is_leaf_r = r_idx >= internal_nodes_count;
            if (overlap_l && is_leaf_l)
            {
                const uint leaf_idx = l_idx - internal_nodes_count;
                if (num_found < uint(max_collision_per_node) && idx < sorted_indices_buffer[leaf_idx])
                {
                    thread_pairs[num_found++] = sorted_indices_buffer[leaf_idx];
                }
            }
            if (overlap_r && is_leaf_r)
            {
                const uint leaf_idx = r_idx - internal_nodes_count;
                if (num_found < uint(max_collision_per_node) && idx < sorted_indices_buffer[leaf_idx])
                {
                    thread_pairs[num_found++] = sorted_indices_buffer[leaf_idx];
                }
            }

            bool traverse_l = (overlap_l && !is_leaf_l);
            bool traverse_r = (overlap_r && !is_leaf_r);

            if (!traverse_l && !traverse_r)
                node = stack[--stack_idx];
            else
            {
                node = (traverse_l) ? l_idx : r_idx;
                if (traverse_l && traverse_r)
                    stack[stack_idx++] = r_idx;
            }
        }
        while (node != 0xffffffff);
    }

    const int thread_id = g_tid.x;
    uint offset = 1;
    shared_query_collision_in[get_shared_index(thread_id)] = num_found;

    for (int d = block_size >> 1; d > 0; d >>= 1)
    {
        GroupMemoryBarrierWithGroupSync();
        if (thread_id < d)
        {
            const uint ai = offset * (2 * thread_id + 1) - 1;
            const uint bi = offset * (2 * thread_id + 2) - 1;
            shared_query_collision_in[get_shared_index(bi)] += shared_query_collision_in[get_shared_index(ai)];
        }
        offset <<= 1;
    }
    if (thread_id == 0)
    {
        shared_query_collision_in[get_shared_index(block_size - 1)] = 0;
    }
    for (int d = 1; d < block_size; d <<= 1)
    {
        offset >>= 1;
        GroupMemoryBarrierWithGroupSync();
        if (thread_id < d)
        {
            const uint ai = offset * (2 * thread_id + 1) - 1;
            const uint bi = offset * (2 * thread_id + 2) - 1;
            const uint t = shared_query_collision_in[get_shared_index(ai)];
            shared_query_collision_in[get_shared_index(ai)] = shared_query_collision_in[get_shared_index(bi)];
            shared_query_collision_in[get_shared_index(bi)] += t;
        }
    }

    if (thread_id == 0)
    {
        int original_value;
        InterlockedAdd(total_pairs_buffer[0], shared_query_collision_in[block_size - 1], original_value);
        shared_query_collision_global_offset[0] = original_value;
    }
    GroupMemoryBarrierWithGroupSync();

    if (num_found > 0)
    {
        const uint thread_offset = shared_query_collision_global_offset[0] +
            shared_query_collision_in[get_shared_index(thread_id)] - num_found;
        uint i = 0;
        while (thread_offset + i < uint(max_collision_pairs) && i < num_found)
        {
            collision_pairs_buffer[thread_offset + i] = uint2(idx, thread_pairs[i]);
            i++;
        }
    }
}

/**
 * 查询碰撞三角面
 * @param id 线程ID
 */
[numthreads(BLOCK_SIZE,1,1)]
void query_collision_triangles(uint3 id : SV_DispatchThreadID)
{
    int idx = id.x;
    if (idx < total_pairs_buffer[0])
    {
        const int f0 = collision_pairs_buffer[idx].x;
        const int f1 = collision_pairs_buffer[idx].y;
        const int v00 = face_indices_buffer[f0 * 3];
        const int v01 = face_indices_buffer[f0 * 3 + 1];
        const int v02 = face_indices_buffer[f0 * 3 + 2];
        const int v10 = face_indices_buffer[f1 * 3];
        const int v11 = face_indices_buffer[f1 * 3 + 1];
        const int v12 = face_indices_buffer[f1 * 3 + 2];

        if (v00 == v10 || v00 == v11 || v00 == v12 ||
            v01 == v10 || v01 == v11 || v01 == v12 ||
            v02 == v10 || v02 == v11 || v02 == v12)
            return;


        // TODO(changyu): only consider obj-obj collision now...
        // 只考虑了不同物体之间的碰撞。同一个物体不同位置的碰撞还没有实现
        if (vert_group_buffer[v00] == vert_group_buffer[v10])
        {
            return;
        }

        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v00, v10, v11,
                            v12, collision_detection_dist);
        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v01, v10, v11,
                            v12, collision_detection_dist);
        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v02, v10, v11,
                            v12, collision_detection_dist);
        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v10, v00, v01,
                            v02, collision_detection_dist);
        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v11, v00, v01,
                            v02, collision_detection_dist);
        add_collision_pairs(vertices_x_buffer, exact_collision_pairs_buffer, total_exact_pairs_buffer, v12, v00, v01,
                            v02, collision_detection_dist);
    }
}


groupshared lbvh_aabb aabb_shared_data[512];

/**
 * @param tid 当前线程局部ID
 * @param block_size 线程块大小
 *  @param block_idx 线程块ID
*/
inline void aabb_reduce(int tid, const int block_size, int block_idx)
{
    int i = block_idx * block_size * 2 + tid;
    int grid_size = block_size * 2 * aabb_grid_size;
    //初始化为最值
    aabb_shared_data[tid].lower = asfloat(0x7f7fffff);
    aabb_shared_data[tid].upper = asfloat(0xff7fffff);
    while (i < face_total_count)
    {
        // 合并当前线程处理的两个 AABB（i 和 i+blockSize）
        aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], triangle_aabbs_buffer[i]);
        if (i + block_size < face_total_count)
        {
            aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], triangle_aabbs_buffer[i + block_size]);
        }
        i += grid_size; // 处理下一批数据
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 512)
    {
        if (tid < 256) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 256]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 256)
    {
        if (tid < 128) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 128]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 128)
    {
        if (tid < 64) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 64]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 64)
    {
        if (tid < 32) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 32]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 32)
    {
        if (tid < 16) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 16]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 16)
    {
        if (tid < 8) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 8]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 8)
    {
        if (tid < 4) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 4]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 4)
    {
        if (tid < 2) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 2]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (block_size >= 2)
    {
        if (tid < 1) { aabb_shared_data[tid] = merge_aabb(aabb_shared_data[tid], aabb_shared_data[tid + 1]); }
    }
    GroupMemoryBarrierWithGroupSync();
    if (tid == 0)
    {
        partial_aabb_buffer[block_idx] = aabb_shared_data[0];
    }
}

[numthreads(512,1,1)]
void aabb_reduce_512(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 512, gid.x);
}

[numthreads(256,1,1)]
void aabb_reduce_256(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 256, gid.x);
}

[numthreads(128,1,1)]
void aabb_reduce_128(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 128, gid.x);
}

[numthreads(64,1,1)]
void aabb_reduce_64(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 64, gid.x);
}

[numthreads(32,1,1)]
void aabb_reduce_32(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 32, gid.x);
}

[numthreads(16,1,1)]
void aabb_reduce_16(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 16, gid.x);
}

[numthreads(8,1,1)]
void aabb_reduce_8(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 8, gid.x);
}

[numthreads(4,1,1)]
void aabb_reduce_4(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 4, gid.x);
}

[numthreads(2,1,1)]
void aabb_reduce_2(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 2, gid.x);
}

[numthreads(1,1,1)]
void aabb_reduce_1(uint3 gid : SV_GroupID, uint3 g_tid : SV_GroupThreadID)
{
    aabb_reduce(g_tid.x, 1, gid.x);
}

/// 物理求解部分 ///


/**
 * 应用外力(重力和控制器施加的力)
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void apply_external_force(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count)
    {
        if (vert_inv_mass_buffer[idx] > 0)
        {
            // 应用阻尼作用
            for (int i = 0; i < 3; i++)
            {
                vert_velocity_buffer[idx * 3 + i] *= exp(-dt * damping_coefficient);
            }

            // const float rotation_factor = 0.05f; //旋转因子。虽然目前可能没什么用
            // 原版这里有一个什么“固定顶点”。暂时忽略
            // 应用重力
            vert_velocity_buffer[idx * 3 + 2] = float(z_up * gravity * dt);
            // 应用控制器的力
            // 本来这里会加一个法向速度，但是因为要用到角速度，所以不考虑
            // float3 dpos = vertices_x_buffer[idx] - controller_position;
            // float3 new_dpos 
            for (int i = 0; i < 3; i++)
            {
                vert_velocity_buffer[idx * 3 + i] += controller_velocity[i];
            }
        }
        else
        {
            for (int i = 0; i < 3; i++)
            {
                vert_velocity_buffer[idx * 3 + i] = 0.f;
            }
        }
        // 最后计算新位置
        const float3 v = float3(vert_velocity_buffer[idx * 3 + 0], vert_velocity_buffer[idx * 3 + 1],
                                vert_velocity_buffer[idx * 3 + 2]);
        vert_new_x_buffer[idx] = vertices_x_buffer[idx] + v * dt;
    }
}


// 由于UAV限制将三个参数合并到一个缓冲区中，使用下面的方式存取
inline float load_mu_from_buffer(const int index)
{
    return cell_mu_lambda_multiplier_buffer[index];
}

inline void store_mu_to_buffer(const int index, const float value)
{
    cell_mu_lambda_multiplier_buffer[index] = value;
}

inline float load_lambda_from_buffer(const int index)
{
    return cell_mu_lambda_multiplier_buffer[index + cell_total_count];
}

inline void store_lambda_to_buffer(const int index, const float value)
{
    cell_mu_lambda_multiplier_buffer[index + cell_total_count] = value;
}

inline float load_multiplier_from_buffer(const int index)
{
    return cell_mu_lambda_multiplier_buffer[index + cell_total_count * 2];
}

inline void store_multiplier_to_buffer(const int index, const float value)
{
    cell_mu_lambda_multiplier_buffer[index + cell_total_count * 2] = value;
}

/**
 * FEM约束求解
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE/2,1,1)]
void solve_fem_constraints(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    // 不是刚体
    if (idx < cell_total_count && rigid_vert_group_buffer[cell_indices_buffer[idx * 4]] < 0)
    {
        const float eps = 1e-6f;
        // 应变与应力计算
        float3x3 ds;
        for (int i = 0; i < 3; i++)
        {
            ds[i] = vert_new_x_buffer[cell_indices_buffer[idx * 4 + i]] -
                vert_new_x_buffer[cell_indices_buffer[idx * 4 + 3]];
        }
        const float3x3 ds_inv = load_matrix_float(cell_ds_inv_buffer, idx);
        const float3x3 F = mul(ds, ds_inv);
        float E[3][3], sigma[3][3];
        float tr_E;
        // 奇异值分解（SVD）处理反转
        // 防止形变梯度奇异（如体积坍缩），提升数值稳定性
        {
            float U[3][3], sig[3][3], V[3][3];

            ssvd3x3(F, U, sig, V);
            // 截断奇异值至安全范围
            for (int i = 0; i < 3; i++)
            {
                const float min_x_val = 0.05f;
                const float max_x_val = 1.7f;
                sig[i][i] = min(max(min_x_val, sig[i][i]), max_x_val);
            }

            float E_diag[3] = {
                0.5f * (sig[0][0] * sig[0][0] - 1.0f),
                0.5f * (sig[1][1] * sig[1][1] - 1.0f),
                0.5f * (sig[2][2] * sig[2][2] - 1.0f)
            };
            tr_E = E_diag[0] + E_diag[1] + E_diag[2];
            sig[0][0] = 2.0f * load_mu_from_buffer(idx) * E_diag[0] + load_lambda_from_buffer(idx) * tr_E;
            sig[1][1] = 2.0f * load_mu_from_buffer(idx) * E_diag[1] + load_lambda_from_buffer(idx) * tr_E;
            sig[2][2] = 2.0f * load_mu_from_buffer(idx) * E_diag[2] + load_lambda_from_buffer(idx) * tr_E;

            for (int i = 0; i < 3; ++i)
            {
                for (int k = 0; k < 3; ++k)
                {
                    E[i][k] = 0;
                    sigma[i][k] = 0;
                    for (int j = 0; j < 3; ++j)
                    {
                        E[i][k] += U[i][j] * E_diag[j] * V[k][j];
                        sigma[i][k] += U[i][j] * sig[j][j] * V[k][j];
                    }
                }
            }
        }
        // 本构模型与能量计算
        float psi = 0.0;
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                psi += E[i][j];
            }
        }
        psi = load_mu_from_buffer(idx) * psi + 0.5 * load_lambda_from_buffer(idx) * tr_E * tr_E;

        // 约束力梯度与求解
        float H[3][3];
        for (int i = 0; i < 3; ++i)
            for (int k = 0; k < 3; ++k)
            {
                H[i][k] = 0;
                for (int j = 0; j < 3; ++j)
                    H[i][k] += sigma[i][j] * cell_ds_inv_buffer[idx * 9 + k * 3 + j];
            }
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                H[i][j] *= cell_volume_init_buffer[idx];
            }
        }
        float sum_normGradC = 0.f;
        for (int i = 0; i < 3; i++)
        {
            sum_normGradC += vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 0]] * H[i][0] * H[i][0];
            sum_normGradC += vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 1]] * H[i][1] * H[i][1];
            sum_normGradC += vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 2]] * H[i][2] * H[i][2];
            sum_normGradC += vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 3]] * (H[i][0] + H[i][1] + H[i][2]) * (H
                [i][0] + H[i][1] + H[i][2]);
        }

        const float relaxation_factor = 0.1;
        #define XPBD
        #ifdef XPBD
        // XPBD约束求解
        // 计算弹性势能
        const float U = cell_volume_init_buffer[idx] * psi;
        float C = sqrt(2.0f * U);
        const float yE = load_mu_from_buffer(idx) * (3.0f * load_lambda_from_buffer(idx) + 2.0f *
            load_mu_from_buffer(idx)) / (load_mu_from_buffer(idx) + load_lambda_from_buffer(idx)); //杨氏模量
        const float alpha = 1.0f / (yE * dt * dt); //柔度系数
        sum_normGradC += C * C * alpha;
        float s = -(C * C + C * alpha * load_multiplier_from_buffer(idx)) / sum_normGradC;
        if (sum_normGradC > eps)
        {
            store_multiplier_to_buffer(idx, load_multiplier_from_buffer(idx) - s);
        }
        s *= relaxation_factor;
        #else
        const float C = cell_volume_init_buffer[idx] * psi;
        float s = -C / sum_normGradC * relaxation_factor;
        #endif
        // 顶点位移更新
        if (sum_normGradC > eps)
        {
            for (int i = 0; i < 3; i++)
            {
                atomic_add_float(vert_delta_pos_buffer, int2(cell_indices_buffer[idx * 4 + 0], i),
                                 s * vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 0]] * H[i][0]);
                atomic_add_float(vert_delta_pos_buffer, int2(cell_indices_buffer[idx * 4 + 1], i),
                                 s * vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 1]] * H[i][1]);
                atomic_add_float(vert_delta_pos_buffer, int2(cell_indices_buffer[idx * 4 + 2], i),
                                 s * vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 2]] * H[i][2]);
                atomic_add_float(vert_delta_pos_buffer, int2(cell_indices_buffer[idx * 4 + 3], i),
                                 s * vert_inv_mass_buffer[cell_indices_buffer[idx * 4 + 3]] *
                                 (-H[i][0] - H[i][1] - H[i][2]));
            }
        }
    }
}

/**
 * 三角面碰撞约束求解
 * 计算点与三角形之间的碰撞约束力，并根据物理参数调整顶点位置，防止穿透。
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE/2,1,1)]
void solve_triangle_point_distance_constraint(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < total_exact_pairs_buffer[0])
    {
        const int v = exact_collision_pairs_buffer[idx].x;
        const int v0 = exact_collision_pairs_buffer[idx].y;
        const int v1 = exact_collision_pairs_buffer[idx].z;
        const int v2 = exact_collision_pairs_buffer[idx].w;

        const float3 p = vert_new_x_buffer[v];
        const float3 p0 = vert_new_x_buffer[v0];
        const float3 p1 = vert_new_x_buffer[v1];
        const float3 p2 = vert_new_x_buffer[v2];

        // 计算三角形参数空间投影
        float b0 = 1.f / 3.f;
        float b1 = b0;
        float b2 = b0;

        const float3 d1 = p1 - p0;
        const float3 d2 = p2 - p0;
        const float3 pp0 = p - p0;
        const float a = dot(d1, d1);
        const float b = dot(d2, d1);
        const float c = dot(pp0, d1);
        const float d = b; // dot(d1, d2)
        const float e = dot(d2, d2);
        const float f = dot(pp0, d2);
        const float det = determinant_2x2(a, b, d, e);
        // 行列式判断是否退化解
        if (det != 0.f)
        {
            // 求解重心坐标 (s,t)
            const float s = (c * e - b * f) / det;
            const float t = (a * f - c * d) / det;
            b0 = 1.0f - s - t; // inside triangle
            b1 = s;
            b2 = t;
            // 处理边界情况（最近点在边或顶点上）...
            if (b0 < 0.f)
            {
                // on edge 1-2
                const float3 d_edge = p2 - p1;
                const float3 d_p = p - p1;
                const float d_edge2 = dot(d_edge, d_edge);
                float x = (d_edge2 == 0.0f) ? 0.5f : dot(d_edge, d_p) / d_edge2;
                if (x < 0.0f) x = 0.0f; // on point 1
                if (x > 1.0f) x = 1.0f; // on point 2
                b0 = 0.0f;
                b1 = (1.0f - x);
                b2 = x;
            }
            else if (b1 < 0.f)
            {
                // on edge 1-2
                const float3 d_edge = p0 - p2;
                const float3 d_p = p - p2;
                const float d_edge2 = dot(d_edge, d_edge);
                float x = (d_edge2 == 0.0f) ? 0.5f : dot(d_edge, d_p) / d_edge2;
                if (x < 0.0f) x = 0.0f; // on point 1
                if (x > 1.0f) x = 1.0f; // on point 2
                b1 = 0.0f;
                b2 = (1.0f - x);
                b0 = x;
            }
            else if (b2 < 0.f)
            {
                // on edge 0-1
                const float3 d_edge = p1 - p0;
                const float3 d_p = p - p0;
                const float d_edge2 = dot(d_edge, d_edge);
                float x = (d_edge2 == 0.0f) ? 0.5f : dot(d_edge, d_p) / d_edge2;
                if (x < 0.0f) x = 0.0f; // on point 1
                if (x > 1.0f) x = 1.0f; // on point 2
                b2 = 0.0f;
                b0 = (1.0f - x);
                b1 = x;
            }
        }
        // 碰撞法向量与距离计算
        // 计算三角形法向量和最近点坐标
        float3 q; // 最近点坐标
        for (int i = 0; i < 3; i++)
        {
            q[i] = p0[i] * b0 + p1[i] * b1 + p2[i] * b2;
        }
        float3 n = p - q; // 碰撞法向量
        // const float3 fn = cross(d1, d2);

        const float dist = length(n); // 实际距离
        n = normalize(n);

        // 约束求解与位移更新
        const float C = dist - collision_detection_dist; // 约束函数

        if (C < 0.0) // 发生穿透
        {
            float s = vert_inv_mass_buffer[v] + vert_inv_mass_buffer[v0] * b0 * b0 + vert_inv_mass_buffer[v1] * b1 * b1
                + vert_inv_mass_buffer[v2] * b2
                * b2; // 计算位移缩放因子
            // 原子操作更新顶点位移
            if (s > 0.0)
            {
                const float relaxation_factor = 1.0;
                s = C / s * collision_stiffness * relaxation_factor;
                for (int i = 0; i < 3; i++)
                {
                    atomic_add_float(vert_delta_pos_buffer, int2(v, i),
                                     -s * vert_inv_mass_buffer[v] * n[i]); // grad
                    atomic_add_float(vert_delta_pos_buffer, int2(v0, i),
                                     -s * vert_inv_mass_buffer[v0] * (-n[i] * b0)); // grad0
                    atomic_add_float(vert_delta_pos_buffer, int2(v1, i),
                                     -s * vert_inv_mass_buffer[v1] * (-n[i] * b1)); // grad1
                    atomic_add_float(vert_delta_pos_buffer, int2(v2, i),
                                     -s * vert_inv_mass_buffer[v2] * (-n[i] * b2)); // grad2
                }
            }
        }
    }
}

/**
 * 更新单步PBD模拟后的顶点位置
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE*4,1,1)]
void pbd_post_solve(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count)
    {
        // 只更新没有被选中的顶点
        if (!vert_selected_indices_buffer[idx])
        {
            vert_new_x_buffer[idx] += asfloat(vert_delta_pos_buffer[idx]);
        }
    }
}

/**
 * 更新PBD一轮步进完成后的顶点位置
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void pbd_advance(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count)
    {
        if (vert_inv_mass_buffer[idx] <= 0.f)
        {
            vert_new_x_buffer[idx] = vertices_x_buffer[idx];
        }
        else
        {
            // 约束物体不掉到地面下方/上方
            if (z_up)
            {
                if (vert_new_x_buffer[idx][2] < ground_height)
                {
                    vert_new_x_buffer[idx][2] = ground_height;
                }
            }
            else
            {
                if (vert_new_x_buffer[idx][2] > ground_height)
                {
                    vert_new_x_buffer[idx][2] = ground_height;
                }
            }
            // 更新顶点速度
            for (int i = 0; i < 3; i++)
            {
                vert_velocity_buffer[idx * 3 + i] = (vert_new_x_buffer[idx][i] - vertices_x_buffer[idx][i]) / dt;
            }
            //更新顶点位置
            vertices_x_buffer[idx] = vert_new_x_buffer[idx];
        }
    }
}

/**
 * 更新刚体质心
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void solve_rigid_init_mass_center(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count && rigid_vert_group_buffer[idx] >= 0)
    {
        const int object_id = rigid_vert_group_buffer[idx];
        for (int i = 0; i < 3; i++)
        {
            atomic_add_float(rigid_mass_center_buffer, object_id * 3 + i,
                             asfloat(vert_mass_buffer[idx]) * vertices_x_buffer[idx][i]);
        }
    }
}

/**
 * 更新刚体角速度矩阵
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void solve_rigid_compute_A(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count && rigid_vert_group_buffer[idx] > 0)
    {
        const int object_id = rigid_vert_group_buffer[idx];
        float q_l[3], p_l[3], A[3][3];
        for (int i = 0; i < 3; i++)
        {
            q_l[i] = vertices_X_buffer[idx][i] - (asfloat(rigid_mass_center_init_buffer[object_id * 3 + i]) / asfloat(
                rigid_mass_buffer[object_id]));
            p_l[i] = vertices_x_buffer[idx][i] - (asfloat(rigid_mass_center_buffer[object_id * 3 + i]) / asfloat(
                rigid_mass_buffer[object_id]));
        }
        outer_product(p_l, q_l, A);
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                atomic_add_float(rigid_angle_velocity_matrix_buffer, object_id * 9 + i * 3 + j,
                                 A[i][j] * asfloat(vert_mass_buffer[idx]));
            }
        }
    }
}

/**
 * 更新刚体旋转矩阵
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void solve_rigid_compute_R(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < gs_object_count)
    {
        float A[3][3];
        for (int i = 0; i < 3; i++)
        {
            for (int j = 0; j < 3; j++)
            {
                A[i][j] = asfloat(rigid_angle_velocity_matrix_buffer[idx * 9 + i * 3 + j]);
            }
        }
        float U[3][3], sigma[3][3], V[3][3];
        svd3x3(A, U, sigma, V);
        const float3x3 U_mat = copy_array_to_matrix3x3(U);
        const float3x3 Vt = transpose(copy_array_to_matrix3x3(V));
        const float3x3 R = mul(U_mat, Vt);
        store_matrix_float(R, rigid_rotation_matrix_buffer, idx);
    }
}

/**
 * 更新刚体位置
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void solve_rigid_update_x(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < vertices_total_count && rigid_vert_group_buffer[idx] >= 0)
    {
        const int object_id = rigid_vert_group_buffer[idx];
        float3 rest_vec;
        for (int i = 0; i < 3; i++)
        {
            rest_vec[i] = vertices_X_buffer[idx][i] - (asfloat(rigid_mass_center_init_buffer[object_id * 3 + i]) /
                asfloat(rigid_mass_buffer[object_id]));
        }
        const float3 cur_vec = mul(load_matrix_float(rigid_rotation_matrix_buffer, object_id), rest_vec);
        float3 target;
        for (int i = 0; i < 3; i++)
        {
            target[i] = (asfloat(rigid_mass_center_buffer[object_id * 3 + i]) /
                asfloat(rigid_mass_buffer[object_id])) + cur_vec[i];
        }
        vertices_x_buffer[idx] += (target - vertices_x_buffer[idx]) * 1.0f;
    }
}


// 用于插值过程数据传递
RWStructuredBuffer<float3x3> apply_interpolation_F_buffer;
/**
 * 实际调用GPU计算GS网格插值更新结果
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void apply_interpolation_i(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < gs_total_count)
    {
        if (is_valid_embed(idx, global_tet_idx_buffer))
        {
            float3 local_X[4], local_x[4];
            for (int c = 0; c < 4; c++)
            {
                const float3 w = float3(
                    global_tet_w_buffer[(idx * 4 + c) * 3 + 0],
                    global_tet_w_buffer[(idx * 4 + c) * 3 + 1],
                    global_tet_w_buffer[(idx * 4 + c) * 3 + 2]
                );
                const int t_id = global_tet_idx_buffer[idx * 4 + c];
                const float3x3 global_DS = transpose(float3x3(
                    vertices_X_buffer[cell_indices_buffer[t_id * 4 + 0]] - vertices_X_buffer[cell_indices_buffer[t_id *
                        4 + 3]],
                    vertices_X_buffer[cell_indices_buffer[t_id * 4 + 1]] - vertices_X_buffer[cell_indices_buffer[t_id *
                        4 + 3]],
                    vertices_X_buffer[cell_indices_buffer[t_id * 4 + 2]] - vertices_X_buffer[cell_indices_buffer[t_id *
                        4 + 3]]
                ));
    
                const float3x3 global_Ds = transpose(float3x3(
                    vertices_x_buffer[cell_indices_buffer[t_id * 4 + 0]] - vertices_x_buffer[cell_indices_buffer[t_id *
                        4 + 3]],
                    vertices_x_buffer[cell_indices_buffer[t_id * 4 + 1]] - vertices_x_buffer[cell_indices_buffer[t_id *
                        4 + 3]],
                    vertices_x_buffer[cell_indices_buffer[t_id * 4 + 2]] - vertices_x_buffer[cell_indices_buffer[t_id *
                        4 + 3]]
                ));
    
                const float3 g_DS_w = mul(global_DS, w);
                const float3 g_Ds_w = mul(global_Ds, w);
    
                local_X[c] = g_DS_w + vertices_X_buffer[cell_indices_buffer[t_id * 4 + 3]];
                local_x[c] = g_Ds_w + vertices_x_buffer[cell_indices_buffer[t_id * 4 + 3]];
            }
            const float3x3 local_DS = transpose(float3x3(
                local_X[0] - local_X[3],
                local_X[1] - local_X[3],
                local_X[2] - local_X[3]
            ));
            const float3x3 local_Ds = transpose(float3x3(
                local_x[0] - local_x[3],
                local_x[1] - local_x[3],
                local_x[2] - local_x[3]
            ));
            const float3 l_w = float3(
                local_tet_w_buffer[idx * 3 + 0],
                local_tet_w_buffer[idx * 3 + 1],
                local_tet_w_buffer[idx * 3 + 2]
            );
            const float3 l_Ds_w = mul(local_Ds, l_w);
            // 更新GS位置
            store_gs_pos(gs_position_buffer, l_Ds_w + local_x[3], idx);

            float3x3 local_DS_inv = inverse_3x3(local_DS);
            float3x3 F = mul(local_Ds, local_DS_inv);
            // 把F存储到中间缓冲区
            apply_interpolation_F_buffer[idx] = F;
            // 剩下的步骤是计算用于旋转SH的gs_local_rot矩阵。因为没有定义所以忽略
        }
    }
}

/**
 * 实际调用GPU计算GS网格插值更新结果
 * @param id 线程ID
 **/
[numthreads(BLOCK_SIZE,1,1)]
void apply_interpolation_ii(uint3 id : SV_DispatchThreadID)
{
    const int idx = id.x;
    if (idx < gs_total_count)
    {
        if (is_valid_embed(idx, global_tet_idx_buffer))
        {
            // 从中间缓冲区恢复F
            const float3x3 F = apply_interpolation_F_buffer[idx];
            const float3x3 Ft = transpose(F);
            const float3x3 tmpB = mul(F, load_matrix_float(cov_buffer, idx));
            const float3x3 B = mul(tmpB, Ft);
            float U[3][3], sigma[3][3], V[3][3];
            ssvd3x3(B, U, sigma, V);
            const float4 rotation = build_quaternion(U);
            // 更新GS旋转
            store_gs_rotation(gs_other_buffer, rotation, idx);
            // 更新GS缩放
            const float3 new_scale = sqrt(max(float3(sigma[0][0], sigma[1][1], sigma[2][2]), 1e-8f));
            store_gs_scale(gs_other_buffer, new_scale, idx);
        }
    }
}
